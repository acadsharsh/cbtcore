generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String    @id @default(cuid())
  name               String?
  email              String?   @unique
  emailVerified      DateTime?
  image              String?
  role               Role      @default(USER)
  performanceCredits Int       @default(0)
  streakDays         Int       @default(0)
  lastAttemptAt      DateTime?
  lastDecayAt        DateTime?
  rankShieldUntil    DateTime?
  accounts           Account[]
  sessions           Session[]
  tests              Test[]
  attempts           Attempt[]
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
}

enum Role {
  USER
  ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Test {
  id               String     @id @default(cuid())
  title            String
  pdfUrl           String?
  visibility       String
  accessCode       String?
  durationMinutes  Int
  markingCorrect   Int
  markingIncorrect Int
  lockNavigation   Boolean    @default(false)
  ownerId          String
  owner            User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  questions        Question[]
  attempts         Attempt[]
  percentileBands  TestPercentileBand[]
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
}

model Question {
  id             String   @id @default(cuid())
  testId         String
  subject        String
  difficulty     String
  questionType   String
  correctOption  String?
  correctNumeric String?
  marksCorrect   Int
  marksIncorrect Int
  imageUrl       String
  cropX          Float
  cropY          Float
  cropW          Float
  cropH          Float
  prompt         String?
  options        Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  test           Test     @relation(fields: [testId], references: [id], onDelete: Cascade)
}

model Attempt {
  id                 String   @id @default(cuid())
  testId             String
  userId             String
  candidateName      String?
  batchCode          String?
  status             String   @default("DRAFT")
  answers            Json
  timeSpent          Json
  events             Json?
  score              Int      @default(0)
  accuracy           Float    @default(0)
  timeTaken          Int      @default(0)
  performanceCredits Int      @default(0)
  streakMultiplier   Float    @default(1.0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  test               Test     @relation(fields: [testId], references: [id], onDelete: Cascade)
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model TestPercentileBand {
  id              String   @id @default(cuid())
  testId          String
  minScore        Int
  maxScore        Int?
  percentileLabel String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  test            Test     @relation(fields: [testId], references: [id], onDelete: Cascade)

  @@index([testId])
  @@unique([testId, minScore])
}
